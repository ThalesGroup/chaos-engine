/*
 *    Copyright (c) 2019 Thales Group
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 *
 */

package com.thales.chaos.util;

import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;
import org.hamcrest.collection.IsIterableContainingInAnyOrder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.springframework.web.util.UriComponentsBuilder;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.URI;
import java.util.List;

import static org.junit.Assert.*;

public class GoogleCloudMetadataUtilTest {
    private static final String RESPONSE = "{\"attributes\":{\"cluster-location\":\"us-central1-a\",\"cluster-name\":\"standard-cluster-1\",\"cluster-uid\":\"b9179f4811325279f261eb4f74917e13fda5ee582702d3b6d76ee395d9637f14\",\"configure-sh\":\"#!/usr/bin/env bash\\n\\n# Copyright 2016 The Kubernetes Authors.\\n#\\n# Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n# you may not use this file except in compliance with the License.\\n# You may obtain a copy of the License at\\n#\\n#     http://www.apache.org/licenses/LICENSE-2.0\\n#\\n# Unless required by applicable law or agreed to in writing, software\\n# distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n# See the License for the specific language governing permissions and\\n# limitations under the License.\\n\\n# Due to the GCE custom metadata size limit, we split the entire script into two\\n# files configure.sh and configure-helper.sh. The functionality of downloading\\n# kubernetes configuration, manifests, docker images, and binary files are\\n# put in configure.sh, which is uploaded via GCE custom metadata.\\n\\nset -o errexit\\nset -o nounset\\nset -o pipefail\\n\\n### Hardcoded constants\\nDEFAULT_CNI_VERSION=\\\"v0.7.5\\\"\\nDEFAULT_CNI_SHA1=\\\"52e9d2de8a5f927307d9397308735658ee44ab8d\\\"\\nDEFAULT_NPD_VERSION=\\\"v0.6.3\\\"\\nDEFAULT_NPD_SHA1=\\\"3a6ac56be6c121f1b94450bfd1a81ad28d532369\\\"\\nDEFAULT_CRICTL_VERSION=\\\"v1.11.1\\\"\\nDEFAULT_CRICTL_SHA1=\\\"527fca5a0ecef6a8e6433e2af9cf83f63aff5694\\\"\\nDEFAULT_MOUNTER_TAR_SHA=\\\"8003b798cf33c7f91320cd6ee5cec4fa22244571\\\"\\n###\\n\\n# Use --retry-connrefused opt only if it's supported by curl.\\nCURL_RETRY_CONNREFUSED=\\\"\\\"\\nif curl --help | grep -q -- '--retry-connrefused'; then\\n  CURL_RETRY_CONNREFUSED='--retry-connrefused'\\nfi\\n\\nfunction set-broken-motd {\\n  cat > /etc/motd <<EOF\\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\\nusing the following commands.\\n\\nMaster instance:\\n  - sudo systemctl status kube-master-installation\\n  - sudo systemctl status kube-master-configuration\\n\\nNode instance:\\n  - sudo systemctl status kube-node-installation\\n  - sudo systemctl status kube-node-configuration\\nEOF\\n}\\n\\nfunction download-kube-env {\\n  # Fetch kube-env from GCE metadata server.\\n  (\\n    umask 077\\n    local -r tmp_kube_env=\\\"/tmp/kube-env.yaml\\\"\\n    curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\\\\n      -H \\\"X-Google-Metadata-Request: True\\\" \\\\\\n      -o \\\"${tmp_kube_env}\\\" \\\\\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\\n    # Convert the yaml format file into a shell-style file.\\n    eval $(python -c '''\\nimport pipes,sys,yaml\\nfor k,v in yaml.load(sys.stdin).iteritems():\\n  print(\\\"readonly {var}={value}\\\".format(var = k, value = pipes.quote(str(v))))\\n''' < \\\"${tmp_kube_env}\\\" > \\\"${KUBE_HOME}/kube-env\\\")\\n    rm -f \\\"${tmp_kube_env}\\\"\\n  )\\n}\\n\\nfunction download-kubelet-config {\\n  local -r dest=\\\"$1\\\"\\n  echo \\\"Downloading Kubelet config file, if it exists\\\"\\n  # Fetch kubelet config file from GCE metadata server.\\n  (\\n    umask 077\\n    local -r tmp_kubelet_config=\\\"/tmp/kubelet-config.yaml\\\"\\n    if curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\\\\n        -H \\\"X-Google-Metadata-Request: True\\\" \\\\\\n        -o \\\"${tmp_kubelet_config}\\\" \\\\\\n        http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config; then\\n      # only write to the final location if curl succeeds\\n      mv \\\"${tmp_kubelet_config}\\\" \\\"${dest}\\\"\\n    elif [[ \\\"${REQUIRE_METADATA_KUBELET_CONFIG_FILE:-false}\\\" == \\\"true\\\" ]]; then\\n      echo \\\"== Failed to download required Kubelet config file from metadata server ==\\\"\\n      exit 1\\n    fi\\n  )\\n}\\n\\nfunction download-kube-master-certs {\\n  # Fetch kube-env from GCE metadata server.\\n  (\\n    umask 077\\n    local -r tmp_kube_master_certs=\\\"/tmp/kube-master-certs.yaml\\\"\\n    curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\\\\n      -H \\\"X-Google-Metadata-Request: True\\\" \\\\\\n      -o \\\"${tmp_kube_master_certs}\\\" \\\\\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\\n    # Convert the yaml format file into a shell-style file.\\n    eval $(python -c '''\\nimport pipes,sys,yaml\\nfor k,v in yaml.load(sys.stdin).iteritems():\\n  print(\\\"readonly {var}={value}\\\".format(var = k, value = pipes.quote(str(v))))\\n''' < \\\"${tmp_kube_master_certs}\\\" > \\\"${KUBE_HOME}/kube-master-certs\\\")\\n    rm -f \\\"${tmp_kube_master_certs}\\\"\\n  )\\n}\\n\\nfunction validate-hash {\\n  local -r file=\\\"$1\\\"\\n  local -r expected=\\\"$2\\\"\\n\\n  actual=$(sha1sum ${file} | awk '{ print $1 }') || true\\n  if [[ \\\"${actual}\\\" != \\\"${expected}\\\" ]]; then\\n    echo \\\"== ${file} corrupted, sha1 ${actual} doesn't match expected ${expected} ==\\\"\\n    return 1\\n  fi\\n}\\n\\n# Get default service account credentials of the VM.\\nGCE_METADATA_INTERNAL=\\\"http://metadata.google.internal/computeMetadata/v1/instance\\\"\\nfunction get-credentials {\\n  curl \\\"${GCE_METADATA_INTERNAL}/service-accounts/default/token\\\" -H \\\"Metadata-Flavor: Google\\\" -s | python -c \\\\\\n    'import sys; import json; print(json.loads(sys.stdin.read())[\\\"access_token\\\"])'\\n}\\n\\nfunction valid-storage-scope {\\n  curl \\\"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\\\" -H \\\"Metadata-Flavor: Google\\\" -s | grep -q \\\"auth/devstorage\\\"\\n}\\n\\n# Retry a download until we get it. Takes a hash and a set of URLs.\\n#\\n# $1 is the sha1 of the URL. Can be \\\"\\\" if the sha1 is unknown.\\n# $2+ are the URLs to download.\\nfunction download-or-bust {\\n  local -r hash=\\\"$1\\\"\\n  shift 1\\n\\n  local -r urls=( $* )\\n  while true; do\\n    for url in \\\"${urls[@]}\\\"; do\\n      local file=\\\"${url##*/}\\\"\\n      rm -f \\\"${file}\\\"\\n      # if the url belongs to GCS API we should use oauth2_token in the headers\\n      local curl_headers=\\\"\\\"\\n      if [[ \\\"$url\\\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\\n        curl_headers=\\\"Authorization: Bearer $(get-credentials)\\\"\\n      fi\\n      if ! curl ${curl_headers:+-H \\\"${curl_headers}\\\"} -f --ipv4 -Lo \\\"${file}\\\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 ${CURL_RETRY_CONNREFUSED} \\\"${url}\\\"; then\\n        echo \\\"== Failed to download ${url}. Retrying. ==\\\"\\n      elif [[ -n \\\"${hash}\\\" ]] && ! validate-hash \\\"${file}\\\" \\\"${hash}\\\"; then\\n        echo \\\"== Hash validation of ${url} failed. Retrying. ==\\\"\\n      else\\n        if [[ -n \\\"${hash}\\\" ]]; then\\n          echo \\\"== Downloaded ${url} (SHA1 = ${hash}) ==\\\"\\n        else\\n          echo \\\"== Downloaded ${url} ==\\\"\\n        fi\\n        return\\n      fi\\n    done\\n  done\\n}\\n\\nfunction is-preloaded {\\n  local -r key=$1\\n  local -r value=$2\\n  grep -qs \\\"${key},${value}\\\" \\\"${KUBE_HOME}/preload_info\\\"\\n}\\n\\nfunction split-commas {\\n  echo $1 | tr \\\",\\\" \\\"\\\\n\\\"\\n}\\n\\nfunction remount-flexvolume-directory {\\n  local -r flexvolume_plugin_dir=$1\\n  mkdir -p $flexvolume_plugin_dir\\n  mount --bind $flexvolume_plugin_dir $flexvolume_plugin_dir\\n  mount -o remount,exec $flexvolume_plugin_dir\\n}\\n\\nfunction install-gci-mounter-tools {\\n  CONTAINERIZED_MOUNTER_HOME=\\\"${KUBE_HOME}/containerized_mounter\\\"\\n  local -r mounter_tar_sha=\\\"${DEFAULT_MOUNTER_TAR_SHA}\\\"\\n  if is-preloaded \\\"mounter\\\" \\\"${mounter_tar_sha}\\\"; then\\n    echo \\\"mounter is preloaded.\\\"\\n    return\\n  fi\\n\\n  echo \\\"Downloading gci mounter tools.\\\"\\n  mkdir -p \\\"${CONTAINERIZED_MOUNTER_HOME}\\\"\\n  chmod a+x \\\"${CONTAINERIZED_MOUNTER_HOME}\\\"\\n  mkdir -p \\\"${CONTAINERIZED_MOUNTER_HOME}/rootfs\\\"\\n  download-or-bust \\\"${mounter_tar_sha}\\\" \\\"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\\\"\\n  cp \\\"${KUBE_HOME}/kubernetes/server/bin/mounter\\\" \\\"${CONTAINERIZED_MOUNTER_HOME}/mounter\\\"\\n  chmod a+x \\\"${CONTAINERIZED_MOUNTER_HOME}/mounter\\\"\\n  mv \\\"${KUBE_HOME}/mounter.tar\\\" /tmp/mounter.tar\\n  tar xf /tmp/mounter.tar -C \\\"${CONTAINERIZED_MOUNTER_HOME}/rootfs\\\"\\n  rm /tmp/mounter.tar\\n  mkdir -p \\\"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\\\"\\n}\\n\\n# Install node problem detector binary.\\nfunction install-node-problem-detector {\\n  if [[ -n \\\"${NODE_PROBLEM_DETECTOR_VERSION:-}\\\" ]]; then\\n      local -r npd_version=\\\"${NODE_PROBLEM_DETECTOR_VERSION}\\\"\\n      local -r npd_sha1=\\\"${NODE_PROBLEM_DETECTOR_TAR_HASH}\\\"\\n  else\\n      local -r npd_version=\\\"${DEFAULT_NPD_VERSION}\\\"\\n      local -r npd_sha1=\\\"${DEFAULT_NPD_SHA1}\\\"\\n  fi\\n  local -r npd_tar=\\\"node-problem-detector-${npd_version}.tar.gz\\\"\\n\\n  if is-preloaded \\\"${npd_tar}\\\" \\\"${npd_sha1}\\\"; then\\n    echo \\\"${npd_tar} is preloaded.\\\"\\n    return\\n  fi\\n\\n  echo \\\"Downloading ${npd_tar}.\\\"\\n  local -r npd_release_path=\\\"${NODE_PROBLEM_DETECTOR_RELEASE_PATH:-https://storage.googleapis.com/kubernetes-release}\\\"\\n  download-or-bust \\\"${npd_sha1}\\\" \\\"${npd_release_path}/node-problem-detector/${npd_tar}\\\"\\n  local -r npd_dir=\\\"${KUBE_HOME}/node-problem-detector\\\"\\n  mkdir -p \\\"${npd_dir}\\\"\\n  tar xzf \\\"${KUBE_HOME}/${npd_tar}\\\" -C \\\"${npd_dir}\\\" --overwrite\\n  mv \\\"${npd_dir}/bin\\\"/* \\\"${KUBE_BIN}\\\"\\n  chmod a+x \\\"${KUBE_BIN}/node-problem-detector\\\"\\n  rmdir \\\"${npd_dir}/bin\\\"\\n  rm -f \\\"${KUBE_HOME}/${npd_tar}\\\"\\n}\\n\\nfunction install-cni-binaries {\\n  local -r cni_tar=\\\"cni-plugins-amd64-${DEFAULT_CNI_VERSION}.tgz\\\"\\n  local -r cni_sha1=\\\"${DEFAULT_CNI_SHA1}\\\"\\n  if is-preloaded \\\"${cni_tar}\\\" \\\"${cni_sha1}\\\"; then\\n    echo \\\"${cni_tar} is preloaded.\\\"\\n    return\\n  fi\\n\\n  echo \\\"Downloading cni binaries\\\"\\n  download-or-bust \\\"${cni_sha1}\\\" \\\"https://storage.googleapis.com/kubernetes-release/network-plugins/${cni_tar}\\\"\\n  local -r cni_dir=\\\"${KUBE_HOME}/cni\\\"\\n  mkdir -p \\\"${cni_dir}/bin\\\"\\n  tar xzf \\\"${KUBE_HOME}/${cni_tar}\\\" -C \\\"${cni_dir}/bin\\\" --overwrite\\n  mv \\\"${cni_dir}/bin\\\"/* \\\"${KUBE_BIN}\\\"\\n  rmdir \\\"${cni_dir}/bin\\\"\\n  rm -f \\\"${KUBE_HOME}/${cni_tar}\\\"\\n}\\n\\n# Install crictl binary.\\nfunction install-crictl {\\n  if [[ -n \\\"${CRICTL_VERSION:-}\\\" ]]; then\\n    local -r crictl_version=\\\"${CRICTL_VERSION}\\\"\\n    local -r crictl_sha1=\\\"${CRICTL_TAR_HASH}\\\"\\n  else\\n    local -r crictl_version=\\\"${DEFAULT_CRICTL_VERSION}\\\"\\n    local -r crictl_sha1=\\\"${DEFAULT_CRICTL_SHA1}\\\"\\n  fi\\n  local -r crictl=\\\"crictl-${crictl_version}-linux-amd64\\\"\\n\\n  # Create crictl config file.\\n  cat > /etc/crictl.yaml <<EOF\\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\\nEOF\\n\\n  if is-preloaded \\\"${crictl}\\\" \\\"${crictl_sha1}\\\"; then\\n    echo \\\"crictl is preloaded\\\"\\n    return\\n  fi\\n\\n  echo \\\"Downloading crictl\\\"\\n  local -r crictl_path=\\\"https://storage.googleapis.com/kubernetes-release/crictl\\\"\\n  download-or-bust \\\"${crictl_sha1}\\\" \\\"${crictl_path}/${crictl}\\\"\\n  mv \\\"${KUBE_HOME}/${crictl}\\\" \\\"${KUBE_BIN}/crictl\\\"\\n  chmod a+x \\\"${KUBE_BIN}/crictl\\\"\\n}\\n\\nfunction install-exec-auth-plugin {\\n  if [[ ! \\\"${EXEC_AUTH_PLUGIN_URL:-}\\\" ]]; then\\n      return\\n  fi\\n  local -r plugin_url=\\\"${EXEC_AUTH_PLUGIN_URL}\\\"\\n  local -r plugin_sha1=\\\"${EXEC_AUTH_PLUGIN_SHA1}\\\"\\n\\n  echo \\\"Downloading gke-exec-auth-plugin binary\\\"\\n  download-or-bust \\\"${plugin_sha1}\\\" \\\"${plugin_url}\\\"\\n  mv \\\"${KUBE_HOME}/gke-exec-auth-plugin\\\" \\\"${KUBE_BIN}/gke-exec-auth-plugin\\\"\\n  chmod a+x \\\"${KUBE_BIN}/gke-exec-auth-plugin\\\"\\n\\n  if [[ ! \\\"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\\\" ]]; then\\n      return\\n  fi\\n  local -r license_url=\\\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\\\"\\n  echo \\\"Downloading gke-exec-auth-plugin license\\\"\\n  download-or-bust \\\"\\\" \\\"${license_url}\\\"\\n  mv \\\"${KUBE_HOME}/LICENSE\\\" \\\"${KUBE_BIN}/gke-exec-auth-plugin-license\\\"\\n}\\n\\nfunction install-kube-manifests {\\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\\n  local dst_dir=\\\"${KUBE_HOME}/kube-manifests\\\"\\n  mkdir -p \\\"${dst_dir}\\\"\\n  local -r manifests_tar_urls=( $(split-commas \\\"${KUBE_MANIFESTS_TAR_URL}\\\") )\\n  local -r manifests_tar=\\\"${manifests_tar_urls[0]##*/}\\\"\\n  if [ -n \\\"${KUBE_MANIFESTS_TAR_HASH:-}\\\" ]; then\\n    local -r manifests_tar_hash=\\\"${KUBE_MANIFESTS_TAR_HASH}\\\"\\n  else\\n    echo \\\"Downloading k8s manifests sha1 (not found in env)\\\"\\n    download-or-bust \\\"\\\" \\\"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha1}\\\"\\n    local -r manifests_tar_hash=$(cat \\\"${manifests_tar}.sha1\\\")\\n  fi\\n\\n  if is-preloaded \\\"${manifests_tar}\\\" \\\"${manifests_tar_hash}\\\"; then\\n    echo \\\"${manifests_tar} is preloaded.\\\"\\n    return\\n  fi\\n\\n  echo \\\"Downloading k8s manifests tar\\\"\\n  download-or-bust \\\"${manifests_tar_hash}\\\" \\\"${manifests_tar_urls[@]}\\\"\\n  tar xzf \\\"${KUBE_HOME}/${manifests_tar}\\\" -C \\\"${dst_dir}\\\" --overwrite\\n  local -r kube_addon_registry=\\\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\\\"\\n  if [[ \\\"${kube_addon_registry}\\\" != \\\"k8s.gcr.io\\\" ]]; then\\n    find \\\"${dst_dir}\\\" -name \\\\*.yaml -or -name \\\\*.yaml.in | \\\\\\n      xargs sed -ri \\\"s@(image:\\\\s.*)k8s.gcr.io@\\\\1${kube_addon_registry}@\\\"\\n    find \\\"${dst_dir}\\\" -name \\\\*.manifest -or -name \\\\*.json | \\\\\\n      xargs sed -ri \\\"s@(image\\\\\\\":\\\\s+\\\\\\\")k8s.gcr.io@\\\\1${kube_addon_registry}@\\\"\\n  fi\\n  cp \\\"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\\\" \\\"${KUBE_BIN}/configure-helper.sh\\\"\\n  if [[ -e \\\"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\\\" ]]; then\\n    cp \\\"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\\\" \\\"${KUBE_BIN}/\\\"\\n  fi\\n\\n  cp \\\"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\\\" \\\"${KUBE_BIN}/health-monitor.sh\\\"\\n\\n  rm -f \\\"${KUBE_HOME}/${manifests_tar}\\\"\\n  rm -f \\\"${KUBE_HOME}/${manifests_tar}.sha1\\\"\\n}\\n\\n# A helper function for loading a docker image. It keeps trying up to 5 times.\\n#\\n# $1: Full path of the docker image\\nfunction try-load-docker-image {\\n  local -r img=$1\\n  echo \\\"Try to load docker image file ${img}\\\"\\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\\n  set +e\\n  local -r max_attempts=5\\n  local -i attempt_num=1\\n  until timeout 30 ${LOAD_IMAGE_COMMAND:-docker load -i} \\\"${img}\\\"; do\\n    if [[ \\\"${attempt_num}\\\" == \\\"${max_attempts}\\\" ]]; then\\n      echo \\\"Fail to load docker image file ${img} after ${max_attempts} retries. Exit!!\\\"\\n      exit 1\\n    else\\n      attempt_num=$((attempt_num+1))\\n      sleep 5\\n    fi\\n  done\\n  # Re-enable errexit.\\n  set -e\\n}\\n\\n# Loads kube-system docker images. It is better to do it before starting kubelet,\\n# as kubelet will restart docker daemon, which may interfere with loading images.\\nfunction load-docker-images {\\n  echo \\\"Start loading kube-system docker images\\\"\\n  local -r img_dir=\\\"${KUBE_HOME}/kube-docker-files\\\"\\n  if [[ \\\"${KUBERNETES_MASTER:-}\\\" == \\\"true\\\" ]]; then\\n    try-load-docker-image \\\"${img_dir}/kube-apiserver.tar\\\"\\n    try-load-docker-image \\\"${img_dir}/kube-controller-manager.tar\\\"\\n    try-load-docker-image \\\"${img_dir}/kube-scheduler.tar\\\"\\n  else\\n    try-load-docker-image \\\"${img_dir}/kube-proxy.tar\\\"\\n  fi\\n}\\n\\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\\n# and places them into suitable directories. Files are placed in /home/kubernetes.\\nfunction install-kube-binary-config {\\n  cd \\\"${KUBE_HOME}\\\"\\n  local -r server_binary_tar_urls=( $(split-commas \\\"${SERVER_BINARY_TAR_URL}\\\") )\\n  local -r server_binary_tar=\\\"${server_binary_tar_urls[0]##*/}\\\"\\n  if [[ -n \\\"${SERVER_BINARY_TAR_HASH:-}\\\" ]]; then\\n    local -r server_binary_tar_hash=\\\"${SERVER_BINARY_TAR_HASH}\\\"\\n  else\\n    echo \\\"Downloading binary release sha1 (not found in env)\\\"\\n    download-or-bust \\\"\\\" \\\"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha1}\\\"\\n    local -r server_binary_tar_hash=$(cat \\\"${server_binary_tar}.sha1\\\")\\n  fi\\n\\n  if is-preloaded \\\"${server_binary_tar}\\\" \\\"${server_binary_tar_hash}\\\"; then\\n    echo \\\"${server_binary_tar} is preloaded.\\\"\\n  else\\n    echo \\\"Downloading binary release tar\\\"\\n    download-or-bust \\\"${server_binary_tar_hash}\\\" \\\"${server_binary_tar_urls[@]}\\\"\\n    tar xzf \\\"${KUBE_HOME}/${server_binary_tar}\\\" -C \\\"${KUBE_HOME}\\\" --overwrite\\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\\n    local -r src_dir=\\\"${KUBE_HOME}/kubernetes/server/bin\\\"\\n    local dst_dir=\\\"${KUBE_HOME}/kube-docker-files\\\"\\n    mkdir -p \\\"${dst_dir}\\\"\\n    cp \\\"${src_dir}/\\\"*.docker_tag \\\"${dst_dir}\\\"\\n    if [[ \\\"${KUBERNETES_MASTER:-}\\\" == \\\"false\\\" ]]; then\\n      cp \\\"${src_dir}/kube-proxy.tar\\\" \\\"${dst_dir}\\\"\\n    else\\n      cp \\\"${src_dir}/kube-apiserver.tar\\\" \\\"${dst_dir}\\\"\\n      cp \\\"${src_dir}/kube-controller-manager.tar\\\" \\\"${dst_dir}\\\"\\n      cp \\\"${src_dir}/kube-scheduler.tar\\\" \\\"${dst_dir}\\\"\\n      cp -r \\\"${KUBE_HOME}/kubernetes/addons\\\" \\\"${dst_dir}\\\"\\n    fi\\n    load-docker-images\\n    mv \\\"${src_dir}/kubelet\\\" \\\"${KUBE_BIN}\\\"\\n    mv \\\"${src_dir}/kubectl\\\" \\\"${KUBE_BIN}\\\"\\n\\n    mv \\\"${KUBE_HOME}/kubernetes/LICENSES\\\" \\\"${KUBE_HOME}\\\"\\n    mv \\\"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\\\" \\\"${KUBE_HOME}\\\"\\n  fi\\n\\n  if [[ \\\"${KUBERNETES_MASTER:-}\\\" == \\\"false\\\" ]] && \\\\\\n     [[ \\\"${ENABLE_NODE_PROBLEM_DETECTOR:-}\\\" == \\\"standalone\\\" ]]; then\\n    install-node-problem-detector\\n  fi\\n\\n  if [[ \\\"${NETWORK_PROVIDER:-}\\\" == \\\"kubenet\\\" ]] || \\\\\\n     [[ \\\"${NETWORK_PROVIDER:-}\\\" == \\\"cni\\\" ]]; then\\n    install-cni-binaries\\n  fi\\n\\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\\n  install-kube-manifests\\n  chmod -R 755 \\\"${KUBE_BIN}\\\"\\n\\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\\n  install-gci-mounter-tools\\n\\n  # Remount the Flexvolume directory with the \\\"exec\\\" option, if needed.\\n  if [[ \\\"${REMOUNT_VOLUME_PLUGIN_DIR:-}\\\" == \\\"true\\\" && -n \\\"${VOLUME_PLUGIN_DIR:-}\\\" ]]; then\\n    remount-flexvolume-directory \\\"${VOLUME_PLUGIN_DIR}\\\"\\n  fi\\n\\n  # Install crictl on each node.\\n  install-crictl\\n\\n  if [[ \\\"${KUBERNETES_MASTER:-}\\\" == \\\"false\\\" ]]; then\\n    # TODO(awly): include the binary and license in the OS image.\\n    install-exec-auth-plugin\\n  fi\\n\\n  # Clean up.\\n  rm -rf \\\"${KUBE_HOME}/kubernetes\\\"\\n  rm -f \\\"${KUBE_HOME}/${server_binary_tar}\\\"\\n  rm -f \\\"${KUBE_HOME}/${server_binary_tar}.sha1\\\"\\n}\\n\\n######### Main Function ##########\\necho \\\"Start to install kubernetes files\\\"\\n# if install fails, message-of-the-day (motd) will warn at login shell\\nset-broken-motd\\n\\nKUBE_HOME=\\\"/home/kubernetes\\\"\\nKUBE_BIN=\\\"${KUBE_HOME}/bin\\\"\\n\\n# download and source kube-env\\ndownload-kube-env\\nsource \\\"${KUBE_HOME}/kube-env\\\"\\n\\ndownload-kubelet-config \\\"${KUBE_HOME}/kubelet-config.yaml\\\"\\n\\n# master certs\\nif [[ \\\"${KUBERNETES_MASTER:-}\\\" == \\\"true\\\" ]]; then\\n  download-kube-master-certs\\nfi\\n\\n# binaries and kube-system manifests\\ninstall-kube-binary-config\\n\\necho \\\"Done for installing kubernetes files\\\"\\n\",\"created-by\":\"projects/203123834228/zones/us-central1-a/instanceGroupManagers/gke-standard-cluster-1-default-pool-3b6eaa7e-grp\",\"enable-oslogin\":\"false\",\"gci-ensure-gke-docker\":\"true\",\"gci-update-strategy\":\"update_disabled\",\"google-compute-enable-pcid\":\"true\",\"instance-template\":\"projects/203123834228/global/instanceTemplates/gke-standard-cluster-1-default-pool-2aadd76d\",\"kube-env\":\"ALLOCATE_NODE_CIDRS: \\\"true\\\"\\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=60m,memory=435Mi,ephemeral-storage=41Gi;node_labels=beta.kubernetes.io/fluentd-ds-ready=true,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos\\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURDekNDQWZPZ0F3SUJBZ0lRRzJtRVROcW1TMDVEelZ6cmVETUFyakFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlRM1kyRmhNMlkwTnkwMk9XUTBMVFExTURjdE9ERTFZUzFqWVRoa01qRXlNMk01T0RndwpIaGNOTVRrd01USTBNVEkxTlRBMVdoY05NalF3TVRJek1UTTFOVEExV2pBdk1TMHdLd1lEVlFRREV5UTNZMkZoCk0yWTBOeTAyT1dRMExUUTFNRGN0T0RFMVlTMWpZVGhrTWpFeU0yTTVPRGd3Z2dFaU1BMEdDU3FHU0liM0RRRUIKQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUUM3aGVXTHdYK28reHRXUjdOaWU0U0liNFY5RTFsN0pmY0dyOC9vYlVpMQo2WlpWanRqQmVRK0VselhpeWNZUHBoa2pVeFZ3bE42Yks5WG1IOGhJTWVXbkZtUGZ2QTl0a3VaM05FeW9tWi9WCndsdTNpb0pJTGFMTGhLcWk2bDZaR2VSdkQ2eHhYNUJ1UWJmYTFXY2hHbWJMQUozaXJUYlJXaEZlU0lObjJEVmwKVzdIVUxYbURWTjN1dDAwbEtlTUZIM1A0QTE1cG1CUTFDNldtMUtnYWZXQ0FsclVYL2pHRXJkeU95Z0laNk9yVApDYVg4YjdxaDgwdEdhdGJsUHRvc3pCN0ZBZXFucW9rV0hkZlpjUW5LeVhlVWloazRPbWJ6QWNmL2RZdS81Q0NkCklxZm96WjdHVDhycFNnQVFUbXF6UGYwWmRoTWFqQmYzODRYNnBHK3F5ckh2QWdNQkFBR2pJekFoTUE0R0ExVWQKRHdFQi93UUVBd0lDQkRBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFBcQpOTStSdFdmTHZzckNGNklYdDRkV01USGxZc2tnTmVHcEpxbWppNzN4ZHU4SFlqM3VkaWQ4RWhMVjJtUE9ka3RmCndIektweTlJQVdIeGhiTzl1RUoycDlWYXlVQTg0OUlZYldIWitiMkNRc3VhYmRZMDc1R1VubmJVNnUwNjlyZ2MKRVlMeWtkc3d0ajZ3UGMwTHhwekpMRDJCRnJqemtDYXBSZGNIWE93SVBxRGpFNUVGTFNGamg2RmFiSVcwdG95SwpwazR2R3EvdXFmN1A4QWZHMDgzNDVqcER0OGRkR3cyOUdkRndNczRoelhBQnh4N2xhSVBVdks0OTNRdTI0cHhMCkxleGpubTNnR1ZUNmFxeFFSWWxPbWs0VHBveEdFc1JITHd0YlhPSUtCcXR5MEZzbnNjU0JqRHlrS05LcE5weGwKYUFtcldDZUFLc0pZcXRDMFk5R1YKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\\nCLUSTER_IP_RANGE: 10.8.0.0/14\\nCLUSTER_NAME: standard-cluster-1\\nCREATE_BOOTSTRAP_KUBECONFIG: \\\"true\\\"\\nDNS_DOMAIN: cluster.local\\nDNS_SERVER_IP: 10.11.240.10\\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\\nELASTICSEARCH_LOGGING_REPLICAS: \\\"1\\\"\\nENABLE_CLUSTER_DNS: \\\"true\\\"\\nENABLE_CLUSTER_LOGGING: \\\"false\\\"\\nENABLE_CLUSTER_MONITORING: stackdriver\\nENABLE_CLUSTER_REGISTRY: \\\"false\\\"\\nENABLE_CLUSTER_UI: \\\"true\\\"\\nENABLE_L7_LOADBALANCING: glbc\\nENABLE_METRICS_SERVER: \\\"true\\\"\\nENABLE_NODE_LOGGING: \\\"true\\\"\\nENABLE_NODE_PROBLEM_DETECTOR: standalone\\nENABLE_NODELOCAL_DNS: \\\"false\\\"\\nENV_TIMESTAMP: \\\"2019-01-24T13:55:05+00:00\\\"\\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\\nFEATURE_GATES: DynamicKubeletConfig=false,ExperimentalCriticalPodAnnotation=true\\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\\nHPA_USE_REST_CLIENTS: \\\"true\\\"\\nINSTANCE_PREFIX: gke-standard-cluster-1-b9179f48\\nKUBE_ADDON_REGISTRY: gcr.io/google-containers\\nKUBE_MANIFESTS_TAR_HASH: b74ed73aeb00efcc7057635c18c144d1fc89dc48\\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/kubernetes-release-gke/release/v1.11.10-gke.5/kubernetes-manifests.tar.gz,https://storage.googleapis.com/kubernetes-release-gke-eu/release/v1.11.10-gke.5/kubernetes-manifests.tar.gz,https://storage.googleapis.com/kubernetes-release-gke-asia/release/v1.11.10-gke.5/kubernetes-manifests.tar.gz\\nKUBE_PROXY_TOKEN: xAVXdweL1jXEg44Y5jfYIvH2aefsNO-zy_CY5GoGCfc=\\nKUBELET_ARGS: --v=2 --cloud-provider=gce --experimental-check-node-capabilities-before-mount=true\\n  --allow-privileged=true --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter\\n  --cert-dir=/var/lib/kubelet/pki/ --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig\\n  --experimental-kernel-memcg-notification=true --max-pods=110 --network-plugin=kubenet\\n  --node-labels=beta.kubernetes.io/fluentd-ds-ready=true,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos\\n  --volume-plugin-dir=/home/kubernetes/flexvolume --bootstrap-kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig\\n  --node-status-max-images=25 --registry-qps=10 --registry-burst=20\\nKUBELET_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMyekNDQWNPZ0F3SUJBZ0lRWEZzZUdoeDZzRUpqNmdubUtGVXhoakFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlRM1kyRmhNMlkwTnkwMk9XUTBMVFExTURjdE9ERTFZUzFqWVRoa01qRXlNMk01T0RndwpIaGNOTVRrd01USTBNVE0xTlRBM1doY05NalF3TVRJek1UTTFOVEEzV2pBU01SQXdEZ1lEVlFRREV3ZHJkV0psCmJHVjBNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQTAvd2hSd1FCNGRoVmNwRzYKSHJ3VHFrdEtHYmF2Q3RveXhCUTNwWUNaYlhNQ3d4cXNiUXhHV2V3alFnWTdidU1BRlJ0SVQ4TXJrcktsZlhWNQphd1g4UTlweTlLaDUwaEs5Wm5laGdQenpDdXl4WnNzeE5KcHNuWGd2ZWdmSEozSzRWSW1PR2RDQmxhOTl6NGhQCnhOLy9yZjJ0V3huTjZyZjVOSGhyL0Z1NnZVODBRTUFwVjBDNkNwbE5lZmRmT3Ewb3FIN2lucWdSdmQ5NThlTHkKSGR6UVFGZGN4MDIzZFZsbk9MdWVReDU0K3M3U29mcHFWNHozUi9nTmU3Y3pHcHEwWm5HR3UzZTNvcVFrcHgwQQp0bWoxR1ZPSUxTS1ZzdWMyL3lIdWE0SExOd085dGhONkNVOHVtdkZnSDkvN00rR1RyUG1MN2dtQi81QlIySXlZClJwVnhOd0lEQVFBQm94QXdEakFNQmdOVkhSTUJBZjhFQWpBQU1BMEdDU3FHU0liM0RRRUJDd1VBQTRJQkFRQlUKejFxR21VQm40c1cvYnJKdXQ5NzFwN2taRVp1bjFOT2tkbmE0U2wrcjVnV1RGaTQ1K1VEU21nNXNQdlV5NXBsVApXbUV1dlhNazVhTTZkUU5abk5UNW1RQUs0c2tPT0hremdNYVJQWld2YlNxaHBITFdIcGVGYm1uME1zQkhqRnpxCjVsdG82c05ESEJoa1FFTFJRdXBRWnVxTW5YZ21wZ0MrUjM0UDV4L2pPSkVVbmFoUDlFWHoyZlpoYndwR3NFaDQKYUswWk1wYWh6R1JkRFRWOXJLUVVzbHpkZnk2VytsemlFRUV4czZxak1wbXpmNzVVTzM1Z3BwaDFXYjloQldMbAp0V0kybzVLRmR1SzVRTkVKSEQ4eUlsazlpMnZWZnBNTHpScThwYVpWMEhybkhFejNsZ2dUbWlCdG03b3QzTmNVCmtBVkNPNDlZQ3dRUm5udVFGVFRnCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\\nKUBELET_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb2dJQkFBS0NBUUVBMC93aFJ3UUI0ZGhWY3BHNkhyd1Rxa3RLR2JhdkN0b3l4QlEzcFlDWmJYTUN3eHFzCmJReEdXZXdqUWdZN2J1TUFGUnRJVDhNcmtyS2xmWFY1YXdYOFE5cHk5S2g1MGhLOVpuZWhnUHp6Q3V5eFpzc3gKTkpwc25YZ3ZlZ2ZISjNLNFZJbU9HZENCbGE5OXo0aFB4Ti8vcmYydFd4bk42cmY1Tkhoci9GdTZ2VTgwUU1BcApWMEM2Q3BsTmVmZGZPcTBvcUg3aW5xZ1J2ZDk1OGVMeUhkelFRRmRjeDAyM2RWbG5PTHVlUXg1NCtzN1NvZnBxClY0ejNSL2dOZTdjekdwcTBabkdHdTNlM29xUWtweDBBdG1qMUdWT0lMU0tWc3VjMi95SHVhNEhMTndPOXRoTjYKQ1U4dW12RmdIOS83TStHVHJQbUw3Z21CLzVCUjJJeVlScFZ4TndJREFRQUJBb0lCQUJVUjhIVFFqeWRWaTFpeAo1MS82cmJHMWZnNEVQRzNGdGxvSzhHVUEzVDhsdVZhUEppaEltZzJDRFJjWTYzdGdFTGdJV0MybFpvVlVRR0t4CjlIbVF4THd4MEU5RkY2YXJ1aXVmSkd4ZnVBQ1QraVlQZURxVVJzdDRFSy8rYWVzZjJmWjlIYVN2TnRJYitWTlIKWnl4WVgxOTU0V3MycTJMekdrLyswQ3pyS1NwN3NITGFRcmlFRk1Jcnd5VVhVL1haeVZpUmVoUHhrbU8rV1EzUQp5WENJQVJjMFlDVkJkeEwxelBPaXBTZEJ0czYyUFRDVVlnTy9NeEx0aVZEY2FIV3pCZEREZWxxYnhHYStHWFU5CnladHdtcHBMYkNRVVN3WEU3Tk1objJZVE1QRmVlaHV3U2ZCS0NmenJhM2t5ZlB0SG5KKzIrUHVwZldkQUJQL1kKN0dENGI2RUNnWUVBK3pvVWVXV1VPVFJkMUJJaFkzYnZ4RXJLMWdmTHkvRHBQY2tYQlEwMU02YlYrMmg1VEt1RgpqLy91cGhRa1dWVjFKUENyM2lpMjMwRlFoQVNldVJWc3dIdzRoMVhUY2lrN1BSWEF0UDAzQ3hRdEZ5WTJReVZiCjZZRTh3azFmb2Y1bm1oKzNvOFBhelkyUjhpN2NPU054WXlpV3JSTFh3TmxvYWY3RG01OU15azhDZ1lFQTJBTXYKTTZXaTNTNk81VW92WTR4K2R3OFNMNzhKN1JhVXZWOEphNk5EOWp3U0w5M3c3NXNHc3NZUGd6c01IdGZaVkNLVwpETmlRZ0NwNDFzcThucmpoR2VNWkNzcG03SHFsejhjbkROK3pYZGRUVGhIVTJ6eGFPNlc2VUlWNEcvNk1JQXM0Cm80MDNuRWRuSGVjSXMrempRM3gycG5taUhFdS8xRno0c0M0TStKa0NnWUJCUFd6eHRaSlBaS3oxRkp3OUV6YmkKbDdXaTdUVmNTYnlZUWU5TGJZbWlWekg4YnI0SlRnV0tScUUzMmNVeXVjR0pEVUxrbDFnZUUvMFB1NDlvYXdycAoxWmhzZExwTFRDL0pCaXdjRkNIR0s4QWw0ZE4zam0wVzcydlMzWHIzTzNTMkRvU0c3NmFUZUs4czRFUnFSaXo4CjNoNTY1WWpIMk8ySGtSUkZCcEpQZXdLQmdFVWlaOFlBMmlvdUQzL2xDVnUwQ0htMGNoNmo1dHBob3NNbEdvKy8KbGkzRnRoQnAyUVhtdVBNWW5yaGllcE9ZZzY4QXpzTlh3SSswaUM0K2ZyWFIrQUZnQkpER2pNQmMxSnEyWTVJawpPblRyU0hjeEQ4NEc5OTRsUVljcDRISWRPdDI2bWFzR3RHaXBGYUNsWTh5cUlXWmsvRmgxajJPOC9xMUtBREhxCjJ5M3BBb0dBYm4xSGJkOEs0aDh3RnNzVVA2TVJ3Q1QxODh5RUExQS9peVU4Vy8vZWxuRWNvWDVXTzBvQjNubjMKYTc2V3BMZ3RuWWgybUFHT1pJb1pURHFVK2p2Z2kwVGRQZHlQZXlPVmdhNi8zM0RqNml0dSt6Nit2OUZEdWU2bQpia1ZKa3RVcU1qc0dLbmhaeWJrV2hSWVlmdXRsK3VxaHZVMm1EU1RJc2xZWGVFZ1dLK2M9Ci0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==\\nKUBERNETES_MASTER: \\\"false\\\"\\nKUBERNETES_MASTER_NAME: 35.224.1.178\\nLOGGING_DESTINATION: gcp\\nMONITORING_FLAG_SET: \\\"false\\\"\\nNETWORK_PROVIDER: kubenet\\nNODE_LOCAL_SSDS_EXT: \\\"\\\"\\nNODE_PROBLEM_DETECTOR_TOKEN: k4rd7CBs23lmSN8SZLHz9aS2GRENyQLylBnigk0hS-c=\\nREMOUNT_VOLUME_PLUGIN_DIR: \\\"true\\\"\\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \\\"true\\\"\\nSALT_TAR_HASH: \\\"\\\"\\nSALT_TAR_URL: https://storage.googleapis.com/kubernetes-release-gke/release/v1.11.10-gke.5/kubernetes-salt.tar.gz,https://storage.googleapis.com/kubernetes-release-gke-eu/release/v1.11.10-gke.5/kubernetes-salt.tar.gz,https://storage.googleapis.com/kubernetes-release-gke-asia/release/v1.11.10-gke.5/kubernetes-salt.tar.gz\\nSERVER_BINARY_TAR_HASH: 2ed888101b1b398cce1b5149f23a9c6ef6c730b6\\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/kubernetes-release-gke/release/v1.11.10-gke.5/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/kubernetes-release-gke-eu/release/v1.11.10-gke.5/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/kubernetes-release-gke-asia/release/v1.11.10-gke.5/kubernetes-server-linux-amd64.tar.gz\\nSERVICE_CLUSTER_IP_RANGE: 10.11.240.0/20\\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\\nZONE: us-central1-a\\n\",\"kube-labels\":\"beta.kubernetes.io/fluentd-ds-ready=true,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos\",\"kubelet-config\":\"apiVersion: kubelet.config.k8s.io/v1beta1\\nauthentication:\\n  anonymous:\\n    enabled: false\\n  webhook:\\n    enabled: false\\n  x509:\\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\\nauthorization:\\n  mode: Webhook\\ncgroupRoot: /\\nclusterDNS:\\n- 10.11.240.10\\nclusterDomain: cluster.local\\nenableDebuggingHandlers: true\\nevictionHard:\\n  memory.available: 100Mi\\n  nodefs.available: 10%\\n  nodefs.inodesFree: 5%\\nfeatureGates:\\n  DynamicKubeletConfig: false\\n  ExperimentalCriticalPodAnnotation: true\\nkind: KubeletConfiguration\\nkubeReserved:\\n  cpu: 60m\\n  ephemeral-storage: 41Gi\\n  memory: 435Mi\\nreadOnlyPort: 10255\\nstaticPodPath: /etc/kubernetes/manifests\\n\",\"user-data\":\"#cloud-config\\n\\nwrite_files:\\n  - path: /etc/systemd/system/kube-node-installation.service\\n    permissions: 0644\\n    owner: root\\n    content: |\\n      [Unit]\\n      Description=Download and install k8s binaries and configurations\\n      After=network-online.target\\n\\n      [Service]\\n      Type=oneshot\\n      RemainAfterExit=yes\\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\\n      # Use --retry-connrefused opt only if it's supported by curl.\\n      ExecStartPre=/bin/bash -c 'OPT=\\\"\\\"; if curl --help | grep -q -- \\\"--retry-connrefused\\\"; then OPT=\\\"--retry-connrefused\\\"; fi; /usr/bin/curl --fail --retry 5 --retry-delay 3 $OPT --silent --show-error -H \\\"X-Google-Metadata-Request: True\\\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh'\\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\\n      ExecStart=/home/kubernetes/bin/configure.sh\\n\\n      [Install]\\n      WantedBy=kubernetes.target\\n\\n  - path: /etc/systemd/system/kube-node-configuration.service\\n    permissions: 0644\\n    owner: root\\n    content: |\\n      [Unit]\\n      Description=Configure kubernetes node\\n      After=kube-node-installation.service\\n\\n      [Service]\\n      Type=oneshot\\n      RemainAfterExit=yes\\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\\n\\n      [Install]\\n      WantedBy=kubernetes.target\\n\\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\\n    permissions: 0644\\n    owner: root\\n    content: |\\n      [Unit]\\n      Description=Kubernetes health monitoring for container runtime\\n      After=kube-node-configuration.service\\n\\n      [Service]\\n      Restart=always\\n      RestartSec=10\\n      RemainAfterExit=yes\\n      RemainAfterExit=yes\\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\\n\\n      [Install]\\n      WantedBy=kubernetes.target\\n\\n  - path: /etc/systemd/system/kubelet-monitor.service\\n    permissions: 0644\\n    owner: root\\n    content: |\\n      [Unit]\\n      Description=Kubernetes health monitoring for kubelet\\n      After=kube-node-configuration.service\\n\\n      [Service]\\n      Restart=always\\n      RestartSec=10\\n      RemainAfterExit=yes\\n      RemainAfterExit=yes\\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\\n\\n      [Install]\\n      WantedBy=kubernetes.target\\n\\n  - path: /etc/systemd/system/kube-logrotate.timer\\n    permissions: 0644\\n    owner: root\\n    content: |\\n      [Unit]\\n      Description=Hourly kube-logrotate invocation\\n\\n      [Timer]\\n      OnCalendar=hourly\\n\\n      [Install]\\n      WantedBy=kubernetes.target\\n\\n  - path: /etc/systemd/system/kube-logrotate.service\\n    permissions: 0644\\n    owner: root\\n    content: |\\n      [Unit]\\n      Description=Kubernetes log rotation\\n      After=kube-node-configuration.service\\n\\n      [Service]\\n      Type=oneshot\\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\\n\\n      [Install]\\n      WantedBy=kubernetes.target\\n\\n  - path: /etc/systemd/system/kubernetes.target\\n    permissions: 0644\\n    owner: root\\n    content: |\\n      [Unit]\\n      Description=Kubernetes\\n\\n      [Install]\\n      WantedBy=multi-user.target\\n\\nruncmd:\\n - systemctl daemon-reload\\n - systemctl enable kube-node-installation.service\\n - systemctl enable kube-node-configuration.service\\n - systemctl enable kube-container-runtime-monitor.service\\n - systemctl enable kubelet-monitor.service\\n - systemctl enable kube-logrotate.timer\\n - systemctl enable kube-logrotate.service\\n - systemctl enable kubernetes.target\\n - systemctl start kubernetes.target\\n\"},\"cpuPlatform\":\"Intel Broadwell\",\"description\":\"\",\"disks\":[{\"deviceName\":\"persistent-disk-0\",\"index\":0,\"mode\":\"READ_WRITE\",\"type\":\"PERSISTENT\"}],\"guestAttributes\":{},\"hostname\":\"gke-standard-cluster-1-default-pool-3b6eaa7e-f33c.c.gemalto-cspeng.internal\",\"id\":1579878562121987821,\"image\":\"projects/gke-node-images/global/images/gke-11110-gke5-cos-69-10895-277-0-v190619-pre\",\"licenses\":[{\"id\":\"1001010\"},{\"id\":\"1001003\"},{\"id\":\"6880041984096540132\"}],\"machineType\":\"projects/203123834228/machineTypes/g1-small\",\"maintenanceEvent\":\"NONE\",\"name\":\"gke-standard-cluster-1-default-pool-3b6eaa7e-f33c\",\"networkInterfaces\":[{\"accessConfigs\":[{\"externalIp\":\"34.67.121.22\",\"type\":\"ONE_TO_ONE_NAT\"}],\"dnsServers\":[\"169.254.169.254\"],\"forwardedIps\":[\"35.188.85.226\"],\"gateway\":\"10.128.0.1\",\"ip\":\"10.128.0.44\",\"ipAliases\":[],\"mac\":\"42:01:0a:80:00:2c\",\"mtu\":1460,\"network\":\"projects/203123834228/networks/default\",\"subnetmask\":\"255.255.240.0\",\"targetInstanceIps\":[]}],\"preempted\":\"FALSE\",\"remainingCpuTime\":-1,\"scheduling\":{\"automaticRestart\":\"TRUE\",\"onHostMaintenance\":\"MIGRATE\",\"preemptible\":\"FALSE\"},\"serviceAccounts\":{\"203123834228-compute@developer.gserviceaccount.com\":{\"aliases\":[\"default\"],\"email\":\"203123834228-compute@developer.gserviceaccount.com\",\"scopes\":[\"https://www.googleapis.com/auth/devstorage.read_only\",\"https://www.googleapis.com/auth/logging.write\",\"https://www.googleapis.com/auth/monitoring\",\"https://www.googleapis.com/auth/servicecontrol\",\"https://www.googleapis.com/auth/service.management.readonly\",\"https://www.googleapis.com/auth/trace.append\"]},\"default\":{\"aliases\":[\"default\"],\"email\":\"203123834228-compute@developer.gserviceaccount.com\",\"scopes\":[\"https://www.googleapis.com/auth/devstorage.read_only\",\"https://www.googleapis.com/auth/logging.write\",\"https://www.googleapis.com/auth/monitoring\",\"https://www.googleapis.com/auth/servicecontrol\",\"https://www.googleapis.com/auth/service.management.readonly\",\"https://www.googleapis.com/auth/trace.append\"]}},\"tags\":[\"gke-standard-cluster-1-b9179f48-node\"],\"virtualClock\":{\"driftToken\":\"0\"},\"zone\":\"projects/203123834228/zones/us-central1-a\"}";
    private HttpServer server;
    private Integer port;
    private URI uri;

    @Before
    public void setUp () throws Exception {
        InetSocketAddress socket = new InetSocketAddress(0);
        server = HttpServer.create(socket, 0);
        server.createContext("/test", new MyHandler());
        server.setExecutor(null);
        server.start();
        port = server.getAddress().getPort();
        uri = UriComponentsBuilder.newInstance()
                                  .scheme("http")
                                  .host("localhost")
                                  .port(port)
                                  .path("/test")
                                  .build()
                                  .toUri();
    }

    @After
    public void tearDown () {
        server.stop(0);
    }

    @Test
    public void fetchGoogleCloudIdentity () {
        GoogleCloudMetadataUtil.fetchGoogleCloudInstanceIdentity(uri);
        GoogleCloudMetadataUtil.GoogleCloudInstanceIdentity identity = GoogleCloudMetadataUtil.getGoogleCloudInstanceIdentity();
        assertNotNull(identity);
        assertEquals(1579878562121987821L, (long) identity.getId());
        assertEquals("gke-standard-cluster-1-default-pool-3b6eaa7e-f33c", identity.getName());
        assertEquals("projects/203123834228/zones/us-central1-a", identity.getZone());
        assertEquals("projects/gke-node-images/global/images/gke-11110-gke5-cos-69-10895-277-0-v190619-pre", identity.getImage());
    }

    private class MyHandler implements HttpHandler {
        @Override
        public void handle (HttpExchange httpExchange) throws IOException {
            List<String> strings = httpExchange.getRequestHeaders().get("Metadata-Flavor");
            assertThat(strings, IsIterableContainingInAnyOrder.containsInAnyOrder("Google"));
            httpExchange.getResponseHeaders().set("Content-Type", "application/json");
            httpExchange.sendResponseHeaders(200, RESPONSE.length());
            OutputStream os = httpExchange.getResponseBody();
            os.write(RESPONSE.getBytes());
            os.close();
        }
    }
}